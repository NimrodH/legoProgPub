<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        //////////////////// Ort MODE FUNCTIONS/////////////////////////////////
        function reportConnect(newElement) {
            console.log("reportConnect");
            ///for each mode write the model/ write user time and error / create next automtic stage
        }

        function reportWrongMove(wrongConnection, wrongModelConnection) {
            console.log("reportWrongMove");

            postData('https://cconnect0.editorx.io/lego1/_functions/myFunction', { "connection" : "aaa", "connectedTo" : "bbb" })
                .then((data) => {
                    console.log(data); // JSON data parsed by `data.json()` call
                })
                .catch(response => console.log("Erorr in then: " + response));
            /*
            const xhttp = new XMLHttpRequest();
            xhttp.onload = function() {
                console.log("XMLHttpRequest returned");
            }
            xhttp.open("POST", "https://cconnect0.editorx.io/lego1/_functions/myFunction?connectedTo=aaa&connection=bbb");
            xhttp.send();
            */
            console.log("reportWrongMove 23");
        }


        async function postData(url = '', data = {}) {
            // Default options are marked with *
            //console.log("postData: ") + JSON.stringify(data);
            const response = await fetch(url, {
                method: 'POST', // *GET, POST, PUT, DELETE, etc.
                mode: 'no-cors', // no-cors, *cors, same-origin
                cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
                credentials: 'omit', // include, *same-origin, omit
                headers: {
                    'Content-Type': 'application/json'
                    // 'Content-Type': 'application/x-www-form-urlencoded',
                },
                redirect: 'follow', // manual, *follow, error
                referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
                body: JSON.stringify(data) // body data type must match "Content-Type" header
            });
            
           // console.log("response.json: " + response.json());
            return response.json(); // parses JSON response into native JavaScript objects
        }


        window.onmessage = (event) => {
            if (event.data) {
                console.log(`HTML Component received a message: ${event.data}`);
                // additional code here
            }
        }

        function sendMessage(msg) {
            window.parent.postMessage(msg, "https://cconnect0.editorx.io/lego1");
        }


        /////////////////// GAME GLOBAL VERIABLES //////////////////////////
        const notSelectedColor = new BABYLON.Color3(1, 0, 1);//pink
        const selectedColor = new BABYLON.Color3(1, 1, 0);//yellow
        let selectedConnection;///the sphere that was clicked on one of the elements outside the model
        //let modelSelectedConnection;///the sphere that was clicked on one of the elements in the model
        let modelsArray = [];
        let currentModel;
        /////////////////// GAME FUNCTIONS //////////////////////////
        function createModel() {
            model = meshBlock(scene, 1);
            model.position.x = -20;
            model.metadata = {
                inModel: true,
                blockNum: 0,
                numOfBlocks: 0
            };
            modelsArray.push(model);
            return model;
        }

        function getModelSelectedConnection(model) {
            return model.metadata.selectedConnection;
        }
        function setModelSelectedConnection(model, selectedConnectionSphere) {
            model.metadata.selectedConnection = selectedConnectionSphere;
        }

        function setSelectedConnectionColor(r, g, b) {
            sendMessage({ "R": r });
            if (selectedConnection) {
                selectedConnection.parent.material.diffuseColor = new BABYLON.Color3(r, g, b);
            }
        }
        function colorBlue() {
            setSelectedConnectionColor(0, 0, 1);
        }
        function colorRed() {
            setSelectedConnectionColor(1, 0, 0);
        }
        function colorBlack() {
            setSelectedConnectionColor(0, 0, 0);
        }

        function connect() {
            if (!(selectedConnection && getModelSelectedConnection(currentModel))) {
                console.log("please select points");
                reportWrongMove(selectedConnection, getModelSelectedConnection(currentModel))
                return;
            }
            ///create element to place in the model
            newElement = selectedConnection.parent.clone(selectedConnection.parent.name);
            ///set any of its childrens with its own matirial and action
            let children = newElement.getChildren();
            for (let index = 0; index < children.length; index++) {
                const element = children[index];
                initMeshContactSphere(element);
            }

            newElement.material = new BABYLON.StandardMaterial("myMaterial", scene);
            newElement.material.diffuseColor = selectedConnection.parent.material.diffuseColor;


            ///calculate the vector between the selected spheres in the element and in the model
            const matrix_sc = selectedConnection.parent.computeWorldMatrix(true);
            var global_pos_sc = BABYLON.Vector3.TransformCoordinates(selectedConnection.position, matrix_sc);
            //console.log("global_pos_sc : " + global_pos_sc);
            const matrix_m = getModelSelectedConnection(currentModel).parent.computeWorldMatrix(true);
            var global_pos_m = BABYLON.Vector3.TransformCoordinates(getModelSelectedConnection(currentModel).position, matrix_m);
            //console.log("global_pos_m : " + global_pos_m);
            var global_delta = global_pos_m.subtract(global_pos_sc);
            //console.log("global_delta : " + global_delta);

            ///move the elment by the calaculated vector, then add it to model
            newElement.position.addInPlace(global_delta);
            newElement.setParent(currentModel);
            newElement.metadata = {
                inModel: true,
                blockNum: currentModel.metadata.numOfBlocks + 1,
                connection: selectedConnection,
                connectedTo: getModelSelectedConnection(currentModel)
            };
            currentModel.metadata.numOfBlocks = currentModel.metadata.numOfBlocks + 1;
            getModelSelectedConnection(currentModel).scaling = new BABYLON.Vector3(0.9, 0.9, 0.9);
            ///TODO:rescale if removing block
            setModelSelectedConnection(currentModel, null);
            reportConnect(newElement);///newElement has connectedTo object
        }
        ///turn the elemets
        function flipModel() {
            currentModel.rotation.x = 0;
            currentModel.rotation.y = 0;
            currentModel.rotation.z = Math.PI / 2;
            /*
            let array = currentModel.getChildren()
            for (let index = 0; index < array.length; index++) {
                const element = array[index];
                if (element.metadata){
                    console.log("connection id: " + element.metadata.connection.parent.id)//////////////////////
                    console.log("connectedTo id: " + element.metadata.connectedTo.id)//////////////////////
                    console.log("connection name: " + element.metadata.connection.parent.name)//////////////////////
                    console.log("connectedTo name: " + element.metadata.connectedTo.name)//////////////////////
                    console.log("name: " + element.name)///
                }
                //console.log("name: " + currentModel.name)//
           }
           */
        }

        function flipZ() {
            if (selectedConnection) {
                selectedConnection.parent.rotation.x = 0
                selectedConnection.parent.rotation.y = 0
                selectedConnection.parent.rotation.z = Math.PI / 2;
            }

        }
        function flipX() {
            if (selectedConnection) {
                selectedConnection.parent.rotation.z = 0
                selectedConnection.parent.rotation.y = 0
                selectedConnection.parent.rotation.x = Math.PI / 2;
                //selectedConnection.parent.rotation.x = 0;///not work for sphere
            }

        }
        function flipY() {
            if (selectedConnection) {
                selectedConnection.parent.rotation.z = 0
                selectedConnection.parent.rotation.x = 0
                selectedConnection.parent.rotation.y = Math.PI / 2;
            }

        }
        ///defign and highlite the conection sphere
        function doClickConnection(event) {
            if (event.source.parent.metadata && event.source.parent.metadata.inModel) {
                doModelConnection(event.source);
                return;
            } else {
                doElementConnection(event.source);
            }
        }

        function doElementConnection(connectionSphere) {
            if (selectedConnection && connectionSphere !== selectedConnection) {
                selectedConnection.material.diffuseColor = notSelectedColor;
            }
            selectedConnection = connectionSphere;

            m = selectedConnection.material;
            if (m.diffuseColor == selectedColor) {
                m.diffuseColor = notSelectedColor;
                selectedConnection = null;
            } else {
                m.diffuseColor = selectedColor;
            }
        }



        ///defign and highlite the conection sphere in the model (called from doClickConnection)
        function doModelConnection(connectionSphere) {

            if (getModelSelectedConnection(currentModel) && connectionSphere !== getModelSelectedConnection(currentModel)) {
                getModelSelectedConnection(currentModel).material.diffuseColor = notSelectedColor;
            }
            setModelSelectedConnection(currentModel, connectionSphere);

            m = getModelSelectedConnection(currentModel).material;
            if (m.diffuseColor == selectedColor) {
                m.diffuseColor = notSelectedColor;
                setModelSelectedConnection(currentModel, null);
            } else {
                m.diffuseColor = selectedColor;
            }
        }

        ///add sphere to Block/wheel 
        function addMeshContactSphere(meshParent, meshPosition) {
            let tempSphere = BABYLON.MeshBuilder.CreateSphere("p" + meshPosition, { diameter: 1.2 })
            tempSphere.parent = meshParent;
            tempSphere.position.x = meshPosition;
            initMeshContactSphere(tempSphere);
        }

        ///set matirial and action to connection sphere (called from addMeshContactSphere and connect) 
        function initMeshContactSphere(tempSphere) {
            const myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            myMaterial.diffuseColor = notSelectedColor;
            tempSphere.material = myMaterial;

            tempSphere.actionManager = new BABYLON.ActionManager(scene);
            tempSphere.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, doClickConnection))
        }

        ///create round elment (Wheel)
        function meshWheel(scene, wheelWidth) {
            const wheel = BABYLON.MeshBuilder.CreateCylinder("c" + wheelWidth, { height: 1, diameter: 2 });
            const myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            myMaterial.diffuseColor = new BABYLON.Color3(0.54, 0.13, 0.54);
            wheel.material = myMaterial;
            wheel.rotation.x = Math.PI / 2;
            addMeshContactSphere(wheel, 0);
            return wheel;
        }

        ///create rectangle element (block)
        function meshBlock(scene, blockWidth) {
            const box = BABYLON.MeshBuilder.CreateBox("b" + blockWidth, { width: blockWidth, height: 1 });
            const myMaterial = new BABYLON.StandardMaterial("myMaterial", scene);
            myMaterial.diffuseColor = new BABYLON.Color3(0.54, 0.13, 0.54);
            box.material = myMaterial;
            //box.position.x = 2;
            blockWidthFloor = Math.floor(blockWidth / 2);
            if (blockWidthFloor == blockWidth / 2) { //זוגי
                for (let index = 0; index < blockWidthFloor; index++) {
                    addMeshContactSphere(box, index - 0.5)
                    addMeshContactSphere(box, index + 0.5)
                }
            } else { //פירדי
                for (let index = 0; index < blockWidthFloor + 1; index++) {
                    addMeshContactSphere(box, index)
                    if (index !== 0) {
                        addMeshContactSphere(box, -index)
                    }
                }
            }
            return box
        }
        ////////////////////// end of game functions ///////////////////////////
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function () { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true, disableWebGL2Support: false }); };
        /////////// CREATE SCENE ///////////////////////////
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);

            const camera = new BABYLON.ArcRotateCamera("Camera", - Math.PI / 2, Math.PI / 4, 10, BABYLON.Vector3.Zero());
            camera.attachControl(canvas, true);

            const light1 = new BABYLON.DirectionalLight("DirectionalLight", new BABYLON.Vector3(0, -1, 1));
            const light2 = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0));
            light1.intensity = 0.75;
            light2.intensity = 0.5;

            const b1X5 = meshBlock(scene, 5);
            const b1X3 = meshBlock(scene, 3);
            b1X3.position.y = 3;
            const b1X2 = meshBlock(scene, 2);
            b1X2.position.y = -3;
            const c1 = meshWheel(scene, 1);
            c1.position.y = 6;
            currentModel = createModel();
            // GUI
            var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
            createButton(0, "/", flipY);
            createButton(50, "---", flipX);
            createButton(100, "|", flipZ);
            createButton(200, "< <", connect);
            createButton(300, "turn model", flipModel);
            createButton(-100, " ", colorBlue).background = "blue";
            createButton(-150, " ", colorRed).background = "red";
            createButton(-200, " ", colorBlack).background = "black";

            function createButton(position, name, func) {
                let button1 = BABYLON.GUI.Button.CreateSimpleButton("but1", name);
                button1.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                button1.top = position;
                button1.width = "150px"
                button1.height = "40px";
                button1.color = "white";
                button1.cornerRadius = 20;
                button1.background = "gray";
                button1.onPointerUpObservable.add(func);
                advancedTexture.addControl(button1);
                return button1;
            }
            return scene;
        };
        /////// END CREATE SCENE ////////////
        window.initFunction = async function () {
            var asyncEngineCreation = async function () {
                try {
                    return createDefaultEngine();
                } catch (e) {
                    console.log("the available createEngine function failed. Creating the default engine instead");
                    return createDefaultEngine();
                }
            }

            window.engine = await asyncEngineCreation();
            if (!engine) throw 'engine should not be null.';
            startRenderLoop(engine, canvas);
            window.scene = createScene();
        };

        initFunction().then(() => {
            sceneToRender = scene
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>